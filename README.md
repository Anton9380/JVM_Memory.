
# JVM.организация памяти, сборщики мусора, VisualVM.
### ClassLoader
1. ***JVM*** проверяет уникальность классов. Загрузчик классов подгружает класс JvmComprehension и пакеты указанные в pom.xml(Memory)(package org.example).
2. Подгрузка(loading) :
   1. ***Application***(приложение) ***ClassLoader*** делегирует запрос ***Platform***(в других источниках ***Extension*** - расширение) ***ClassLoader***.
   2. ***Platform ClassLoader*** дальше передает запрос ***Bootstrap***(загрузчик) ***ClassLoader***.
   3. ***Bootstrap ClassLoader*** ищет в пути своем classpath, чтобы проверить, доступен класс или нет. Если класс доступен, он загружается, иначе запрос возвращается ***Platform ClassLoader***.
   4. ***Platform ClassLoader*** проверяет класс в ***Platform*** classpath. Если класс доступен, он загружается, иначе запрос передается в ***Application ClassLoader***.
   5. ***Application ClassLoader*** ищет класс в пути к классам приложения. Если класс доступен, то загружается, иначе вы увидите исключение ClassNotFoundException.
3. Связывание(linking):
   1. ***Verify*** проверка на валидность кода.
   2. ***Prepare*** подготовка примитивов в статических полях.(в нашем случае отсутствуют статические поля.Размещаются в памяти JVM)
   3. ***Resolve*** связывание ссылок на другие классы.
4. Инициализация, выполняются инициализаторы static.
5. Загружаются все данные о классе и константы в ***MetaSpace***.
### Организация памяти
6. В момент вызова метода main в стековой памяти создается фрейм(рабочий стол), в рамках которого данный поток работает с переменными и операндами.
7. В этом рабочем пространстве памяти (выделленом под main фрейме) выделяется место под ***int i***.
8. На 7 строке под new Object в куче (динамически распределяемая область оператитвной памяти,иначе heap(создается при старте JVM)) выделяется соответствующий обьем памяти. А под ссылку ***o*** на этот обьект выделяется место в фрейме main.
9. 8 строка, обьявляем Integer ii, выделяется память в куче и создается ссылка в фрейме main.
10. 9 строка:
    1. Выделяется место в стеке под фрейм метода ***printAll***.
    2. В данном фрейме создаются ссылки на используемые обьекты ***(o, ii)***.
    3. Выделяется память под примитив ***i***.
11. Дальше программа переходит к коду метода ***printAll***.Строка 14, выделяется место в куче под переменную ***uselessVar***,а в фрейме этого метода размещается ссылка на нее.
12. Строка 15:
    1. Создаётся новый фрейм в стеке под ***System.out***.
    2. В куче выделяется место под строку образованную в методе ***println(o.toString() + i + ii)***.
    3. В фрейме размещаются ссылка на строку ***o.toString()*** и обьект ***ii***, примитив ***i***.
    4. Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд, очищается, и пространство становится доступным для следующего метода.
    5. По окончании метода ***printAll***,блок памяти в стеке, отведенный для его нужд, очищается.
    6. Сборщик мусора определяет какие обьекты стали потерянными(утратили все ссылки и болше не используются) и удаляет из кучи ***o.toString(), ii , uselessVar***
13. JVM переходит к строке 10 :
    1. Создаётся новый фрейм в стеке под новый ***System.out***.
    2. В куче выделяется место под строку образованную в методе ***println("finished")***.
    3. В фрейме размещается ссылка на строку "finished".
    4. Когда метод завершает выполнение, фрейм, отведенный для его нужд, очищается.
14. По завершению main стековая память очищается. В куче при этом все обьекты сохраняются не смотря на удаление всех ссылок.
15. Сборщик мусора по окончании программы очищает кучу.
### Управление памятью JVM. Сборка мусора.
1. Разметка: сначала сборщик определяет, какие объекты используются, а какие нет. Те, что используются или доступны для стековых указателей, рекурсивно помечаются как живые.
2. Удаление: сборщик проходит по куче и убирает все объекты, которые не помечены как живые. Эти места в памяти помечаются как свободные.
3. Сжатие: после удаления неиспользуемых объектов все выжившие объекты перемещают, чтобы они были вместе. Это уменьшает фрагментацию и повышает скорость выделения памяти для новых объектов.