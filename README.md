JVM.организация памяти, сборщики мусора, VisualVM.

ClassLoader

JVM проверяет уникальность классов. Загрузчик классов подгружает класс JvmComprehension и пакеты указанные в pom.xml(Memory)(package org.example).

Подгрузка(loading) :

Application(приложение) ClassLoader делегирует запрос Platform(в других источниках Extension - расширение) ClassLoader.
Platform ClassLoader дальше передает запрос Bootstrap(загрузчик) ClassLoader.
Bootstrap ClassLoader ищет в пути своем classpath, чтобы проверить, доступен класс или нет. Если класс доступен, он загружается, иначе запрос возвращается Platform ClassLoader.
Platform ClassLoader проверяет класс в Platform classpath. Если класс доступен, он загружается, иначе запрос передается в Application ClassLoader.
Application ClassLoader ищет класс в пути к классам приложения. Если класс доступен, то загружается, иначе вы увидите исключение ClassNotFoundException.
Связывание(linking):

Verify проверка на валидность кода.
Prepare подготовка примитивов в статических полях.(в нашем случае отсутствуют статические поля.Размещаются в памяти JVM)
Resolve связывание ссылок на другие классы.
Инициализация, выполняются инициализаторы static.

Загружаются все данные о классе и константы в MetaSpace.

Организация памяти

В момент вызова метода main в стековой памяти создается фрейм(рабочий стол), в рамках которого данный поток работает с переменными и операндами.

В этом рабочем пространстве памяти (выделленом под main фрейме) выделяется место под int i.

На 7 строке под new Object в куче (динамически распределяемая область оператитвной памяти,иначе heap(создается при старте JVM)) выделяется соответствующий обьем памяти. А под ссылку o на этот обьект выделяется место в фрейме main.

8 строка, обьявляем Integer ii, выделяется память в куче и создается ссылка в фрейме main.

9 строка:

Выделяется место в стеке под фрейм метода printAll.
В данном фрейме создаются ссылки на используемые обьекты (o, ii).
Выделяется память под примитив i.
Дальше программа переходит к коду метода printAll.Строка 14, выделяется место в куче под переменную uselessVar,а в фрейме этого метода размещается ссылка на нее.

Строка 15:

Создаётся новый фрейм в стеке под System.out.
В куче выделяется место под строку образованную в методе println(o.toString() + i + ii).
В фрейме размещаются ссылка на строку o.toString() и обьект ii, примитив i.
Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд, очищается, и пространство становится доступным для следующего метода.
По окончании метода printAll,блок памяти в стеке, отведенный для его нужд, очищается.
Сборщик мусора определяет какие обьекты стали потерянными(утратили все ссылки и болше не используются) и удаляет из кучи o.toString(), ii , uselessVar
JVM переходит к строке 10 :

Создаётся новый фрейм в стеке под новый System.out.
В куче выделяется место под строку образованную в методе println("finished").
В фрейме размещается ссылка на строку "finished".
Когда метод завершает выполнение, фрейм, отведенный для его нужд, очищается.
По завершению main стековая память очищается. В куче при этом все обьекты сохраняются не смотря на удаление всех ссылок.

Сборщик мусора по окончании программы очищает кучу.

Управление памятью JVM. Сборка мусора.

Разметка: сначала сборщик определяет, какие объекты используются, а какие нет. Те, что используются или доступны для стековых указателей, рекурсивно помечаются как живые.
Удаление: сборщик проходит по куче и убирает все объекты, которые не помечены как живые. Эти места в памяти помечаются как свободные.
Сжатие: после удаления неиспользуемых объектов все выжившие объекты перемещают, чтобы они были вместе. Это уменьшает фрагментацию и повышает скорость выделения памяти для новых объектов.
